---
title: Functions
---

## Docstrings

```py title="docstring anatomy"
def function_name(argument):
    """
    1. Describe what the function does

    2. Args:
        argument (type): description

    3. Returns:
        return_value (type): description

    4. Raises:
        exception (type): description

    optional extra notes
    """
```

```py title="Google Style"
def function_name(arg_1, arg_2):
    """Description of what the function does.

    Args:
        arg_1 (type): description
          extra lines indented
        arg_2 (type, optional): description

    Returns:
        return_value (type): description
        extra lines not indented

    Raises:
        exception (type): description
          extra lines indented

    Notes:
    """
```

```py title="retrieving the docstring 1"
def function_name():
    """Description of what the function does.
    """

print(function_name.__doc__)
```

```py title="retrieving the docstring 2"
# Recommended
import inspect

def function_name():
    """Description of what the function does.
    """

print(inspect.getdoc(function_name))
```

## DRY

> Good programmers write code that humans can understand.

```py title="Dont repeat yourself"
def load_and_plot(path):
  """Load a dataset and plot the first two principal components
  
  Args:
    path (str): the location of a CSV file

  Returns:
    tuple of ndarray: (features, labels)
  """
  # load the dataset
  data = pd.read_csv(path)
  y = data['label'].values
  X = data.drop(columns=['label']).values

  # plot the first two principal components
  pca = PCA(n_components=2).fit_transform(X)
  plt.scatter(pca[:, 0], pca[:, 1])

  # return the features and labels
  return X, y
```

```py title="Do One Thing"
def load_data(path):
  """Load a dataset and return the features and labels
  
  Args:
    path (str): the location of a CSV file

  Returns:
    tuple of ndarray: (features, labels)
  """
  data = pd.read_csv(path)
  y = data['label'].values
  X = data.drop(columns=['label']).values

  return X, y

def plot_data(X):
  """Plot the first two principal components
  
  Args:
    X (numpy.ndarray): features
  """
  pca = PCA(n_components=2).fit_transform(X)
  plt.scatter(pca[:, 0], pca[:, 1])


X, y = load_data('data.csv')
plot_data(X)
```

## Immutable and Mutable

Immutable
- int, float, bool, string, bytes, tuple, frozenset, None

Mutable
- list, set, dict, object, bytesarray, function, ...

```py title="mutable default argument is dangerous"
def append_to_list_bad(list_to_append_to=[]):
  list_to_append_to.append(1)
  return list_to_append_to

print(append_to_list_bad()) # [1]
print(append_to_list_bad()) # [1, 1]

def append_to_list_good(list_to_append_to=None):
  if list_to_append_to is None:
    list_to_append_to = []
  list_to_append_to.append(1)
  return list_to_append_to

print(append_to_list_good()) # [1]
print(append_to_list_good()) # [1]
```

---

## Context Manager

1. set up a context
2. execute the code
3. remove the context

```py title="context manager"
with <context_manager>(<arguments>) as <alias>:
  # run code inside the context manager

# code runs after the context manager is removed
```

```py title="example"
with open('data.txt') as file:
  text = file.read()
  length = len(text)
  print(f"The length of the text is {length}")
```

```py title="create A context manager"
@contextlib.contextmanager
def my_context_manager():
  # set up code
  yield
  # tear down code
```

```py title="database_connection"
@contextlib.contextmanager
def database_connection(url):
  # set up database connection
  db = postgres.connect(url)

  yield db

  # tear down database connection
  db.disconnect()

with database_connection('localhost:5432') as db:
  # use the database connection
  db.execute('SELECT * FROM users')

# database connection is closed
```

```py title="in_dir"
def in_dir(path):
  # save cwd
  original_cwd = os.getcwd()

  # change cwd
  os.chdir(path)

  yield
  
  # restore cwd
  os.chdir(original_cwd)

with in_dir('/data/project/'):
  print(os.listdir())
```

```py title="nested"
def copy(src, dst):
  """Copy a file from src to dst
  
  Args:
    src (str): the source file
    dst (str): the destination file
  """
  with open(src) as src_file:
    with open(dst, 'w') as dst_file:
      for line in src_file:
        dst_file.write(line)

copy('data.txt', 'data_copy.txt')
```

```py title="handling errors"
def get_printer(ip_address):
  """Get a printer by IP address
  
  Args:
    ip_address (str): the IP address of the printer
  """
  printer = connect_to_printer(ip_address)

  try:
    yield printer
  finally:
    printer.disconnect()

with get_printer('192.168.1.100') as printer:
  print(printer.print('Hello, World!'))
```

### Patterns

|setup|teardown|
|----|-----|
|Open|Close|
|Lock|Release|
|change|restore|
|enter|exit|
|start|stop|
|connect|disconnect|

## Advanced Topics 

### Scope

1. Builtin
2. Global
3. Nonlocal
4. Local

#### Global Scope
```py tabs="global"
x = 7

print(x) # 7

def foo():
  global x
  x = 5
  print(x) # 5

foo()

print(x) # 5
```

```py tabs="comparison"
x = 7

print(x) # 7

def foo():
  x = 5
  print(x) # 5

foo()

print(x) # 7
```

#### Nonlocal Scope

```py title="nonlocal"
def foo():
  x = 5

  def bar():
    nonlocal x
    x = 10
    print(x) # 10

  bar()
  print(x) # 10

foo()
```

```py title="comparison"
def foo():
  x = 5

  def bar():
    x = 10
    print(x) # 10

  bar()
  print(x) # 5

foo()
```

### Closure

```py title="closure"
def outer():
  x = 5
  def inner():
    print(x)
  return inner

func = outer()
func() # 5

type(func.__closure__) # <class 'tuple'>
type(func.__closure__[0]) # <class 'cell'>
func.__closure__[0].cell_contents # 5
```

```py title="deleting the variable"
x = 5

def outer(value):
  def inner():
    print(value)
  return inner

func = outer(x)
func() # 5

del x
func() # 5

len(func.__closure__) # 1
func.__closure__[0].cell_contents # 5
```

```py title="overwriting the variable"
x = 5

def outer(value):
  def inner():
    print(value)
  return inner

x = outer(x)
x() # 5


len(x.__closure__) # 1
x.__closure__[0].cell_contents # 5
```

## Decorator

modify **inputs**, **outputs** and/or **side effects** of functions

```py title="simple example"
def double_args(func):
  def wrapper(a, b):
    return func(a * 2, b * 2)
  return wrapper

@double_args
def add(a, b):
  return a + b

add(1, 2) # 6
```

```py title="real world timer"
import time

def timer(func):
  """print the time taken to execute the function"""

  def wrapper(*args, **kwargs):
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    print(f"Time taken: {end_time - start_time} seconds")
    return result
  return wrapper

@timer
def sleep_n_seconds(n):
  time.sleep(n)

sleep_n_seconds(3)
# Time taken: 3.0030000000000000 seconds
```

```py title="real world memorize"
def memorize(func):
  """memorize the result of the function for fast lookup"""

  cache = {}
  def wrapper(*args, **kwargs):
    key = str(args) + str(kwargs)
    if key in cache:
      return cache[key]
    result = func(*args, **kwargs)
    cache[key] = result
    return result
  return wrapper

@memorize
def slow_function(a, b):
  print(f"Calculating {a} + {b}")
  time.sleep(2)
  return a + b

slow_function(1, 2)
# Calculating 1 + 2
# Time taken: 2.0020000000000000 seconds

slow_function(1, 2)
# Time taken: 0.0000000000000000 seconds
```

### metadata

```py title="metadata"
def foo():
  """This is a foo function"""
  pass

print(foo.__doc__) # This is a foo function
print(foo.__name__) # foo

@timer
def bar():
  """This is a bar function"""
  pass

print(bar.__doc__) # 
print(bar.__name__) # wrapper
```

```py title="wraps"
from functools import wraps
import time

def timer(func):
  """print the time taken to execute the function"""

  @wraps(func)
  def wrapper(*args, **kwargs):
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    print(f"Time taken: {end_time - start_time} seconds")
    return result
  return wrapper

@timer
def bar():
  """This is a bar function"""
  pass

print(bar.__doc__) # This is a bar function
print(bar.__name__) # bar
print(bar.__wrapped__) # original function
```

### decorator factory

```py title="simple example"
def run_n_times(n):
  def decorator(func):
    def wrapper(*args, **kwargs):
      for _ in range(n):
        func(*args, **kwargs)
    return wrapper
  return decorator

@run_n_times(3)
def hello():
  print("Hello, World!")

hello()
# Hello, World!
# Hello, World!
# Hello, World!
```

```py title="real world timeout"
from functools import wraps
import time
import signal

def timeout(n_seconds):
  def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
      signal.alarm(n_seconds)
      try: 
        return func(*args, **kwargs))
      finally:
        signal.alarm(0)
    return wrapper
  return decorator

@timeout(3)
def hello():
  time.sleep(5)
  print("Hello, World!")

@timeout(10)
def world():
  time.sleep(5)
  print("World!")

hello() 
# Error: function timed out

world()
# World!
```